//
// C++ Interface: face3d
//
// Description: 
//
//
// Author: Juan Linietsky <reduz@codenix.com>, (C) 2006
//
// Copyright: See COPYING file that comes with this distribution
//
//
#ifndef FACE3D_H
#define FACE3D_H

#include "math_defs.h"
#include "plane.h"
#include "vector3.h"
#include "aabb.h"
#include "matrix4.h"

/**
 *	@author Juan Linietsky <reduz@codenix.com>
 * Simple abstraction of a triangle face. 
 * By default clockwise order is the over side, as well
 * as the plane normal when requesting a plane.
 * Face3 includes some clipping helpers as well.
*/

class Face3{
public:
	
	enum Side {
		SIDE_OVER,
		SIDE_UNDER,
		SIDE_SPANNING,
		SIDE_COPLANAR
	};
	
	
	Vector3 vertex[3];
	
	

	/**
	 * 
	 * @param p_plane plane used to split the face
	 * @param p_res array of at least 3 faces, amount used in functio return
	 * @param p_is_over array of at least 3 booleans, determining which face is over the plane, amount used in functio return
	 * @param _epsilon constant used for numerical error rounding, to add "thickness" to the plane (so coplanar points can happen)
	 * @return amount of faces generated by the split, either 0 (means no split possible), 2 or 3
	 */
	int split_by_plane(const Plane& p_plane,Face3 *p_res,bool *p_is_over,double _epsilon=CMP_EPSILON) const;
	
	Plane get_plane(ClockDirection p_dir = CLOCKWISE ) const;
	Side get_side_of(const Face3& p_face,double _epsilon=CMP_EPSILON,ClockDirection p_clock_dir=CLOCKWISE) const;
	

	bool has_area(double _epsilon=CMP_EPSILON) const;
	
	Vector3 get_median_point() const;
	

	bool intersects_ray(const Vector3& p_from,const Vector3& p_dir,Vector3 * p_intersection=0);
	bool intersects_segment(const Vector3& p_from,const Vector3& p_dir,Vector3 * p_intersection=0);

	ClockDirection get_clock_dir() const; ///< todo, test if this is returning the proper clockwisity
			
	void get_support(const Vector3& p_normal,const Matrix4& p_transform,Vector3 *p_vertices,int* p_count,int p_max) const;
	void project_range(const Vector3& p_normal,const Matrix4& p_transform,float& r_min, float& r_max) const; 
	
	inline AABB get_aabb() const {
	
		AABB aabb( vertex[0], Vector3() );
		aabb.expand_to( vertex[1] );
		aabb.expand_to( vertex[2] );
		return aabb;
	}
			
	bool intersects_aabb(const AABB& p_aabb) const;
	
	Face3();
	Face3(const Vector3 &p_v1,const Vector3 &p_v2,const Vector3 &p_v3);
	~Face3();

};



#endif
